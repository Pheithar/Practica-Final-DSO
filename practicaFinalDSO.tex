\documentclass{uc3mpracticas}

\usepackage{float}

\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                   Plantilla Prácticas UC3M                               %%%
%%%                Universidad Carlos III de Madrid                          %%%
%%%                   Alejandro Valverde Mahou                               %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Permitir cabeceras y pie de páginas personalizados
\pagestyle{fancy}

%Path por defecto de las imágenes
\graphicspath{ {./images/} }

%Declarar formato de encabezado y pie de página de las páginas del documento
\fancypagestyle{doc}{
  %Cabecera
  \headerpr[1]{Alejandro Valverde Mahou}{Diseño de Sistemas Operativos}{Trabajo Final}
  %Pie de Página
  \footerpr{}{}{{\thepage} de \pageref{LastPage}}
}

%Declarar formato de encabezado y pie del título e indice
\fancypagestyle{titu}{%
  %Cabecera
  \headerpr{}{}{}
  %Pie de Página
  \footerpr{}{}{}
}


\appto\frontmatter{\pagestyle{titu}}
\appto\mainmatter{\pagestyle{doc}}


\begin{document}
  %Comienzo formato título
  \frontmatter


  %Portada 1 (Centrado todo)
  \centeredtitle{Images/LogoUC3M.png}{Grado en Ingeniería Informática}{Curso 2019-2020}{Diseño de Sistemas Operativos}{Trabajo Final}

  \vspace{60mm}

  \authors{Alejandro Valverde Mahou}{100383383}{}{}{}{}{}{}

  \newpage


  %Índice
  \tableofcontents

  \newpage

  \listoffigures

  \newpage

  %Comienzo formato documento general
  \mainmatter

  \section{Introducción}

  \subsection{Introducción}

  El \textbf{Sistema Operativo} es el \textit{software} principal de un sistema informático que gestiona el \textit{hardware} y sus recursos, y provee servicios \textit{software} a los programas de aplicación. Su función principal es permitir la comunicación entre usuario y ordenador, y gestioanr sus recursos de manera eficiente.

  \begin{figure}[H]
    \centering
    \imgcenter[40]{Images/DefinicionSO.png}
    \caption{Definición de Sistema Operativo \cite{imagenSO}}
  \end{figure}

  \vspace{2mm}

  El sistema operativo actua como interfaz de usuario, gestor de recursos, y máquina extendida.

  \subsubsection{Interfaz del Usuario}

  Se divide en la interfaz del programador, que se realiza a través de llamadas al sistema y la interfaz del usuario, que se realiza a través de la interfaz gráfica o la línea de comandos.

  \subsubsection{Gestor de Recursos}

  Las áreas de gestión son:

  \begin{itemize}
    \item \textbf{Gestión de Procesamiento}

    Se encarga de controlar el planificador de procesos, incluyendo prioridades y capacidades de multiusuario.

    \item \textbf{Gestión de Memoria}

    Se encarga de repartir la memoria entre procesos, com protección y compartición.

    \item \textbf{Gestión de Almacenamiento}

    Se encarga de la persistencia y etiquetación, independiente del medio físisco, con una visión unificada para programas y usuarios.

    \item \textbf{Gestión de Dispositivos}

    Se encarga de cubrir y abordar las dependencias de \textit{hardware}, y de la gestión de accesos concurrentes.

  \end{itemize}

  \subsubsection{Máquina extendida}

  Las abstracciones fundamentales usadas por los sistemas son los \textbf{Procesos} y los \textbf{Archivos}.

  \vspace{2mm}

  Los procesos se organizan en una jerarquía a través de los árbloes de procesos, y son controlados a través del planificador.

  \vspace{2mm}

  Los archivos contienen las rutas para cada directorio y fichero.

  \vspace{5mm}

  Las \textbf{Máquinas Virtuales} virtualizan ciertos partes del \textit{hardware}. El hipervisor realiza una virtualizacón de toda la máquina, de forma que varios sistemas operativos pueden ser ejecutados simultaneamente.

  \begin{figure}[H]
    \centering
    \imgcenter[60]{Images/hipervisor.png}
    \caption{Hipervisor \cite{hipervisor}}
  \end{figure}

  El hipervisor expande las capacidades \textit{hardware}, de forma que cada sistema operativo puede trabajar simultaneamente con otros.

  \vspace{3mm}

  Existen diferentes tipos de máquinas virtuales, según sus capacidades.
  \begin{figure}[H]
    \centering
    \imgcenter[150]{Images/vm.png}
    \caption{Tipos de Máquinas Virtuales}
  \end{figure}

  \vspace{6mm}

  Las principales características de un sistema operativo son:

  \begin{itemize}
    \item \textbf{Versatilidad y portabilidad}: Puede ejecutarse en diferentes máquinas.
    \item \textbf{Adaptativilidad}: Permite añadir y modificar módulos, en función de la demanda de los usuarios, evolución del \textit{hardware} o aparición de distintos entornos.
    \item \textbf{Multidisciplinalidad}: Integra trabajos de distintas áreas.
    \item \textbf{Complejidad}: Dado que realiza numerosas tareas diferentes, es un programa muy complejo y con muchas líneas de código.
    \item \textbf{Delicado}: Un fallo en culauqier parte del sistema puede provocar un colapso completo del sistema operativo.
  \end{itemize}

  Los objetivos en el diseño de un sistema operativo son:

  \begin{itemize}
    \item \textbf{Rendimiento}: Eficiencia y velocidad.
    \item \textbf{Estabilidad}: Robustez y resistencia.
    \item \textbf{Capacidad}: Prestaciones, flexibilidad y compatibilidad.
    \item \textbf{Seguridad y Protección}.
    \item \textbf{Portabilidad}.
    \item \textbf{Claridad}.
    \item \textbf{Extensibilidad}.
  \end{itemize}

  Estas carecterísticas son incompatibles entre sí, por lo que en el diseño es necesario priorizar una característica sobre otras, buscando el equilibrio entre todas.

  \subsubsection{Estructura del Sistema Operativo}

  \begin{enumerate}
    \item \textbf{Monolítico}

    Es no estructurado. Desde cualquier punto del código se puede acceder a cualquier variable o función. Es dificil de mantener y muy sensible a los errores.

    \item \textbf{Subsistemas}

    Es un sistema monolítico compuesto de subsistemas lógicos. Se agrupan procedimientos y estructuras de datos relacionadas.

    \item \textbf{Por Capas}

    Sistema monolítico, pero estructurado por capas, de forma lógica. Cada capa proporciona acceso únicamente a la interfaz de niveles inferiores, de forma que no hay conexión entre capas no conectadas.

    \item \textbf{Microkernel}

    Una pequeña parte de las acciones se hacen en el kernel. El resto se hacen fuera, a nivel usuario.

  \end{enumerate}

  \begin{figure}[H]
    \centering
    \imgcenter[100]{Images/estructura.png}
    \caption{Estructura del Sistema Operativo MS-DOS \cite{msdos}}
  \end{figure}


  \subsection{Ejecución Asíncrona y Modular}

  Los sistemas operativos son sistemas orientados a eventos.

  \vspace{2mm}

  Los eventos interrumpen la ejecución normal del código, dejándolo en segundo plano y sin actuar, hasta que el manejador del evento termina su ejecución.

  \subsubsection{Ejecución Asíncrona}

  Las señales consta de un evento y un manejador.

  \begin{figure}[H]
    \begin{lstlisting}[style=CStyle]
    int global1; // La comunicacion de funciones se usa a traves de varables globales

    void handler( ... ){ // La funcion manejadora se encarga de tratar el evento
      ...
    }

    int main( ... ){
      ...
      On(event1, handler1); // Se asocia el manejador al evento
      ...
    }
    \end{lstlisting}
    \caption{Estructura de un Manejador de Eventos}
  \end{figure}

  \textbf{Ejemplo completo de señales}:

  El comando \texttt{signal()} añade una señal a un manejador.

  \vspace{2mm}

  El comando \texttt{sigaction()} asocia una señal a un manejador usando una máscara.

  \begin{figure}[H]
    \begin{lstlisting}[style=CStyle]
    #include<stdio.h>
    #include<signal.h>
    #include<unistd.h>

    int s1;

    void sig_handler (int signo){
      printf(" S ");
    }

    int main(void){
      if (signal(s1, sig_handler) == SIG_ERR){
        printf("\nNo se puede capturar SIGINT\n");
      }

      for(int i = 0; i < 5; i++){
        if(i == 2 || i == 4){
          s1();
        }
        printf(i);
      }
      return 0;
    }
    \end{lstlisting}
    \caption{Programación de un Manejador de Ejemplos Básico}
  \end{figure}


  En el código anterior, el resultado obtenido sería: \texttt{0, 1, S, 2, 3, S, 4}.

  \subsubsection{Interrupciones \textit{hardware}}

  Cada periférico puede generar una interrupción y dispone de una línea \textbf{IRQ}(\textit{Interrupt ReQuest}), conectada con el \textbf{PIC}(\textit{Programmable Interrupt COntroller}).

  \vspace{2mm}

  El \textbf{PIC} controla las líneas de \textbf{IRQ} para recibir las señales que envíen.
  \vspace{1mm}
  Si llega una señal:

  \begin{enumerate}
    \item Asigna al \textbf{IRQ} del periférico un valor que guarda en \textbf{PIC}.
    \item Avisa a la \textbf{CPU} a través de la línea de Interrupciones Pendientes(\textbf{INT}).
    \item La \textbf{CPU} procesa el registro del \textbf{PIC}.
    \item La \textbf{CPU} informa de que ha leido correctamente la interrupción.
    \item El \textbf{PIC} anula la lñinea de interrupción procesada.
  \end{enumerate}

  Por último, la \textbf{CPU} almacena la interrupción en el \textbf{IDT}(\textit{Interrupt Description Table}), y guarda el estado actual de l proceso en pila, de forma que puede ejecutar la interrupción y recupera al finalizarlo el contenido del proceso de la pila.

  \begin{figure}[H]
    \centering
    \imgcenter[150]{Images/InterrupcionHW.png}
    \caption{Interrupciones \textit{Hardware}}
  \end{figure}

  \subsubsection{Módulos del kernel}

  Los primeros \textit{kernel} necesitaban incluir código para todo tipo de dispositivos, algo que actualmente es inconcebible debido al gran número de dispositivos que existen. Además, era necesario recompilar el kernel cada vez que se quería añadir un nuevo dispositivo.

  \vspace{3mm}

  Los módulos se crearon para poder superar estas dificultades, permitiendo al \textit{kernel} añadir la inclusión condicional de controladores de dispositivos, los \textbf{drivers}.

  \vspace{1mm}

  Los módulos permiten añadir código de forma dinámica de un driver precompilado. Para poder ser distribuidos, se usan \textbf{bibliotecas dinámicas}(\textit{*.so/*.ko}, \textit{*.dll}).

  \subsubsection{Bibliotecas}

  Las bibliotecas son conjuntos de módulos objeto. Existen dos tipos de bibliotecas:

  \vspace{2mm}

  \textbf{Biblioteca Estática}: Es añadida por el compilador, al igual que los módulos objeto.

  \vspace{2mm}

  \textbf{Biblioteca Dinámica}: Es añadida en tiempo de ejecución, y por tanto debe informarse de su uso en la ejecución.

  Su diferencia principal reside en el uso de memoria. Si dos procesos usan la misma biblioteca estática, debe argarse dos veces, ientras que si usan la misma biblioteca dinámica solo hace falta cargarla una vez. Por tanto, en caso de que varios procesos usan la misma biblioteca, las bibliotecas dinámicas ahorran memoria.


  \section{Funcionamiento del Sistema Operativo}

  El sistema operativo se ejecutrat como programa ejecutable en el arranque del sistema.

  \vspace{2mm}

  El sistema operativo necesita que existan al menos dos modos de ejecución:

  \vspace{3mm}

  \textbf{Modo privilegiado}, o modo kernel: Tiene acceso a todo el espacio de memoria y a todas las instrucciones.

  \vspace{1mm}

  \textbf{Modo ordinario}, o modo usuario: Solo tienen acceso a parte del espacio de memoria e instrucciones.

  \subsubsection{Tratamiento de eventos}

  El sistema operativo espera de forma asíncrona y pasiva a la ejecución de los distintos eventos posibles.

  \vspace{3mm}

  Existen una serie de procesos, denominados \textbf{Procesos del Núcleo} que pertenencen al sistema operativo, y no a los usuarios, como el \textit{firewall} o el antivirus. Estos procesos realizan tareas 'especiales' y son ocultos en funcionamiento al usuario.

  \subsubsection{Proceso de arranque del sistema}

  \begin{enumerate}
    \item \textbf{Reset} pone todo a 0 y se cargan los valores iniciales en la \textbf{ROM}.
    \item Se ejecuta el cargador del sistema, leyendo el trozo del \textbf{disco duro} en \textbf{memoria} y hace el \textit{Power-On Self Test}(\textbf{POST}), que comprueba que no haya ningún cambio en el \textit{hardware} y se carag el \textbf{MBR}(\textit{Master Boot Loader}).
    \item El \textbf{MBR} va al \textbf{disco duro} y al \textbf{BL}(\textit{Boot Loader}) que inicializa el kernel del sistema operativo.
    \item Una vez el kernel se ha iniciado, se carga el sistema y todos los \textit{daemons} necesarios.
  \end{enumerate}

  \vspace{3mm}

  \begin{figure}[H]
    \centering
    \imgcenter[120]{Images/Boot.png}
    \caption{Arranque Simplificado del Sistema Operativo}
  \end{figure}

  \vspace{3mm}

  El \textbf{UEFI} es un programa de arranque que se aloja en una partición especial. Ni puede ser modificado y es muy flexible. Al combinar el \textbf{UEFI} con el \textbf{MBR} aumenta la complejidad y disminuye la seguridad.

  \vspace{2mm}

  Para acelerar el proceso de arranque se inicia en paralelo el \textit{software} y el \textit{hardware}.


  \subsection{Eventos}

  Existen cuatro tipos de eventos, que, ordenados de más cercanos a más lejanos al usuario son: Llamadas al sistema, excepciones, interrupciones \textit{software} e interrupciones \textit{hardware}.

  \vspace{2mm}

  Independientemente del \textit{hardware} del sistema, se utiliza el mismo mecanismo: Antes de la microinstrucción \textit{fetch}, se hace una comprobación de que no haya ningún evento pendiente. Si hay alguno pendiente, se entra en modo priviliegiado y se realiza el evento. Cuando no queda ningún evento activo, se reinstaura el estado de la pila y se vuelve al modo anterior.

  \subsubsection{Llamadas al Sistema}

  Son solicitudes de servicios al sistema operativo. Todas las llamadas suelen llamar a la misma función, y, a través de una tabla secundaria se redirige al comportamiento deseado. Este tratamiento se hace así para que la tabla auxiliar sea lo más compacta posible.

  \vspace{2mm}

  Desde el punto de vista de los usuarios, las llamadas al sistema son funciones, y para la CPU es lo mismo qeu si un periférico hiciera una interrupción, porque se simula una interrupción por \textit{software}.

  \vspace{2mm}

  Se hacen siempre desde modo usuario, y son generadas por las aplicaciones. Son eventos síncronos de \textit{software}

  \subsubsection{Excepciones}

  Son interrupciones de la CPU a sí misma para el tratamiento de rutinas especiales. Son los errores en la programación. Cuando se detecta una excepción, se salta a la subrutina asociada, y se comprueba si se ha generado desde modo usuario o modo kernel.

  \vspace{2mm}

  Si es desde el modo de usuario, y no se esta en modo depuración, se aborta el proceso.

  \vspace{1mm}

  Si es desde modo kernel, se llama a la subrutina \texttt{panic()}, que para el sistema completamente (En \textit{Windows} es el pantallazo azul). De esta forma se evita la sobreescritura indeseada de datos.

  \vspace{3mm}

  \subsubsection{Interrupciones \textit{software}}

  Se encargan de ejecutar las partes críticas llamandose desde el sistema operativo. Se resuelven todas las interrupciones por orden de urgencia, y no se vuelve al modo usuario hasta que no queda ningún evento por tratar.

  \subsubsection{Interrupciones \textit{hardware}}

  Son eventos asíncronos \textit{hardware}. Son formas de avisar al sistema operativo cuando se requiere de algun servicio \textit{hardware}. Son requeridas varias subrutinas para cada evento.

  \vspace{2mm}

  Cuando se inicializa el sistema operativo, se establecen los manejadoresde todas las posibles interrupciones, y, cuando hay una interrupción, se guarda el estado actualñ, se realiza la interrupción y si es necesario, se programa una tarea pendiente. Por último, se reinstaura el estado del sistema.

  \subsection{Procesos del núcleo}

  Pertenecen al \textit{kernel} y se ejecuta siempre en modo privilegiado. Se utilizan cuando se tiene que usar el sistema operativo en una operacion concreta que funciona mejor siendo un proceso independiente. Suelen tener mayor prioridad que el resto de procesos. Un ejemplo de proceso de núcleo son aquellos procesos encargados de realizar las operaciones de bloqueo.



  \section{Introducción a la Gestión de Procesos y Drivers}

  \subsection{Introducción a Procesos y Periféricos}

  \subsubsection{Procesos}


  Un proceso es una unidad de actividad que se caracteriza por la ejecución de una secuencia de instrucciones, un estado actual, y un conjunto de recursos del sistema asociados, o, coloquialmente, un proceso es un programa en ejecución \cite{proceso}.

  \vspace{2mm}

  Los requisitos principales de un sistema operativo son:

  \begin{itemize}
    \item \textbf{Control de recursos} $\rightarrow$ En que lugares se encuentran los distintos recursos (código datos y pila), que archivos se encuentran abiertos...
    \item \textbf{Multiprogramación} $\rightarrow$ Poder tener varias aplicaciones cargadas en memoria, realizar cambios de contexto voluntarios para mejorar la eficiencia de uso del procesador...
    \item \textbf{Protección y compartición} $\rightarrow$ Impedir que un programa o proceso acceda a los datos de otro proceso, pero permitiendo la comunicación en ciertos casos.
    \item \textbf{Jerarquía de procesos} $\rightarrow$ Permitir operaciones que afecten a conjuntos o familias de procesos.
    \item \textbf{Multitarea} $\rightarrow$ Limitar el tiempo de actividad de los procesos no bloqueados, para permitit varios procesos actuando a la vez.
    \item \textbf{Multiproceso} $\rightarrow$ Poder ejecutar varios procesos al mismo tiepo, uno en cada \textit{core}.
  \end{itemize}

  Los sistemas operativos cuentan con una serie de tablas, que actuan como peuqñas bases de datos, y son: \textbf{Tabla de Procesos}, que almacena el \textbf{BCP} de los procesos del sistema; \textbf{Tabla de Memoria}; \textbf{Tabal de Entrada/Salida} y \textbf{Tabla de Ficheros}.

  \vspace{2mm}

  El \textbf{BCP}(\textit{Bloque de Control de Procesos}) es una estructura de datos que almacena la información necesaria para identificar y gestionar un proceso.

  \vspace{5mm}

  Los procesos pueden ser creados o en el arranque del sistema, o cuando un proceso existente hace una llamada al sistema para crear u proceso nuevo.

  \vspace{1mm}

  Un proceso puede terminar de forma voluntaria, o de forma involuntaria, cuando es finalizado por el usuario, el sistema u otro proceso.

  \subsubsection{Periféricos}

  Se consideran periféricos a las unidades o dispositivos de \textit{hardware} a través de los cuales la computadora se comunica con el exterior, y también a los sistemas que almacenan o archivan la información, sirviendo de memoria auxiliar de la memoria principal \cite{periferico}.

  \vspace{2mm}

  Un periférico está compuesto de un dispositivo \textit{hardware}, encargado de realizar la interacción con el entorno, y un módulo de entrada/salida, que actua de interfaz entre el dispositivo y la CPU.

  \begin{figure}[H]
    \centering
    \imgcenter[60]{Images/Periferico.png}
    \caption{Esquema Simplificado de un Periférico}
  \end{figure}

  \vspace{3mm}

  Es necesario incluir el modulo de entrada/salida porque:

  \begin{enumerate}
    \item Existe una gran variedad de periféricos, y una CPU no almacena la información requerida para cada uno de ellos.
    \item Los periféricos son lentos, y su velocidad de transferencia es menor que la de la memoria o el procesador. Necesitan de algo que iguale esas velocidades.
    \item Los formatos y tamaños no siempre coinciden entre los distintos periféricos
  \end{enumerate}

  \vspace{2mm}

  Los periféricos se pueden dividir por:

  \begin{enumerate}
    \item Direccionamiento de E/S
    \begin{itemize}
      \item \textbf{Espacio de memoria conjunto}

      Se puede acceder a las direcciones de memoria del controlador desde la memoria principal.

      \item \textbf{Espacio de memoria separado (puertos)}

      Se accede a los registros del controlador a través de instrucciones en ensamblador especiales.

    \end{itemize}
    \item Unidad de transferencia
    \begin{itemize}
      \item \textbf{Dispositivos de bloque}

      Dispositivos como cintas o discos, se acceden por bloques de \textit{bytes}.

      \item \textbf{Dispositivos de carácter}

      Dispositivos como teclados o impresoras, se acceden por caracteres.

    \end{itemize}
    \item Interacción con computador
    \begin{itemize}
      \item \textbf{E/S programada o directa}

      Está constantemente comprobando si es necesario transferir información. Es lento y muy ineficaz.

      \item \textbf{E/S por interrupciones}

      Solo se actua cuando es necesario enviar la información (no hace comprobaciones constantemente). Mejhora la eficiencia.

      \item \textbf{E/S por DMA (\textit{Direct Memory Access})}

      Solo se avisa cuando se han terminado todas las tareas que tenía encargadas. Se suele usar en dispositivos que se comunican por bloque. Requiere un mayor coste de \textit{hardware}, pero mejora la eficiencia y velocidad.

    \end{itemize}
  \end{enumerate}

  \subsection{C.C.V., C.C.I y Planificación}

  Para poder tener varias aplicaciones en memoria, es necesario dotar a los procesos de un estado. De esta forma, se tiene una lista de procesos listos, cuyo primer proceso pasa al estado ejecutando. El siguiente proceso no puede comenzar a ejectuar hasta que el proceso que esta ejecutando se bloquee o termine.

  \begin{figure}[H]
    \centering
    \imgcenter[104]{Images/CCV.png}
    \caption{Diagrama de Estados de los Procesos con Cambio de Contexto Voluntario}
  \end{figure}


  Para implementar esta estructura y poder realizar \textbf{CCV}(\textit{Cambio de Contexto Voluntario}), es necesario el uso de dos colas diferentes: \textbf{Cola de Listos} y \textbf{Cola de BLoqueados}. Cada una almacena los procesos listos y los procesos bloquedos correspondientemente.
  \begin{figure}[H]

    \begin{lstlisting}[style=CStyle]
    void CCV (){
      procesoActual->estado = BLOQUEADO;    //Primero se pone el proceso actual a bloqueado
      insert(L_BLOQUEADOS, procesoActual);  // Y se inserta en la lista de bloqueados

      proceso = procesoActual;              //Se almacena el proceso actual en una variable auxiliar

      procesoActual = planificador();       // Y se actualia el proceso actual
      procesoActual->estado = EJECUTANDO;   //Poniendose como ejecutando

      //Por ultimo se realiza el cambio de contexto
      cambioContexto(&(proceso), &(procesoActual))
    }
    \end{lstlisting}
    \caption{Pseudocódigo del Cambio de Contexto Voluntario}
  \end{figure}

  El \textbf{planificador} es el encargado de decidir cual es el siguiente proceso que debe ser ejecutado, y la función \textbf{cambioContexto} actua como \textit{activador}, y da control al proceso seleccioando anteriormente.

  \vspace{5mm}

  El \textbf{CCI}(\textit{Cambio de Contexto Involuntario}) permite dividir el tiempo de los procesos, y alternar entre los procesos en ejecución, no exclusivamente cuando el proceso que se está ejecutando termina o se bloquea. De esta forma, según la planificación, se puede alternar entre ejecutando y listo.

  \begin{figure}[H]
    \centering
    \imgcenter[104]{Images/CCI.png}
    \caption{Diagrama de Estados de los Procesos con Cambio de Contexto Involuntario}
  \end{figure}

  Dentro de la planificación, existen 3 niveles:

  \begin{itemize}
    \item \textbf{Planificación a largo plazo}: Decide que procesos deben ponerse a ejecutar. Dado que es lento, se invoca con una frecuencia baja.
    \item \textbf{Planificación a medio plazo}: Es la que decide que procesos deben añadirse a la RAM.
    \item \textbf{Planificación a corto plazo}: Es el proceso más rápido, y que se ejecuta más frecuentemente. Decide que procesos tiene la CPU.
  \end{itemize}

  Características de los planificadores:

  \begin{itemize}
    \item \textbf{Multitarea Apropiativa}: Puede ser con o sin expulsión. Si tiene expulsión, requiere de un reloj que limite el tiempo en ejecución de los procesos. Sin expulsión es CCV y con expulsión es CCI.
    \item \textbf{Clasificación de elementos en las colas}: Esta clasificación puede ser por prioridades, que tienen que ser añadida en cada proceso, o puede ser por tipo, que puede ser, por ejmplo, por más 'rachas' de tiempo usando la CPU.
    \item \textbf{Conocimiento de la CPU}: Aquí se puede tener en cuenta la \textit{Afinidad}, o simpatía de un proceso con una CPU concreta, y la \textit{Simetría}, o capacidades especiales de la CPU para ejecutar un proceso concreto.
  \end{itemize}

  Principales algoritmos de planificación:

  \begin{itemize}
    \item \textbf{\textit{Round Robin}}: Asignación rotatoria de procesos. Se le asigna un tiempo máximo en forma de rodaja a los procesos en ejecución.
    \item \textbf{Por prioridad}: Se pone en ejecución el proceso con mayor prioridad en todo momento. Se suele combinar con otros algoritmos tras relaizar una división en prioridades.
    \item \textbf{\textit{SJF}}: Primero el trabajo más corto. Se ordenan los procesos de menor a mayor.
    \item \textbf{\textit{FIFO}}: El primero en llegar es el primero en ejecutar. Se ejecuta estrictamente en el orden de llegada.
  \end{itemize}


  \subsection{Drivers y Servicios Ampliados}

  Los drivers son la parte del sistema operativo que se encarga de interactuar con todos los controladores posibles. Es la parte más cercana al \textit{hardware}, y es la que permite el flujo de información con el mismo.

  \vspace{3mm}

  No permite la reutilización porque es muy dependiente del sistema operativo.

  \vspace{1mm}

  Como se está creando y añadiende \textit{hardware} nuevo continuamente, aparecen nuevos drivers continuamente. Debido a esto, y a su continua necesiadad de actualizaciones, se utiliza una forma modular de implementación.

  \vspace{2mm}

  El objetivo de los drivers es optimizar lo máximo posible el uso del \textit{hardware}, y permitir añadir y quitar dispositivos \textit{hardware} dinámicamente.

  \vspace{2mm}

  La mayor parte del sistema operativo está ocupada por los drivers. Este código tiene acceso completo al sistema, de forma similar al kernel.

  \vspace{4mm}

  En \textit{Linux} se pueden usar llamadas genéricas, porque todo se trata como si fuera un fichero. Esto permite sustituir el \textit{hardware} sin necesidad de recompilar ni modificar el código.

  \vspace{3mm}

  Cada dispositivo \textit{hardware} tiene un \textit{ID mayor} que identifica el driver que usa, y un \textit{ID minor} que identifica al componente \textit{hardware} en concreto.

  \begin{figure}[H]
    \centering
    \imgcenter[130]{Images/EntradaSalida.png}
    \caption{Arquitectura del Sistema de Entrada/Salida \cite{E/S}}
  \end{figure}

  La clasificación clásica de los drivers es en 3 tipos diferentes:

  \begin{itemize}
    \item \textbf{Dispositivos de caracteres}
    \item \textbf{Dispositivos de bloques}
    \item \textbf{Dispositivos de red}
  \end{itemize}

  \vspace{5mm}

  Los servicios ampliados son módulos utilizados para añadir y/o ampliar las funcionalidades de los drivers. Es un driver que comunica con otro driver, en lugar de comunicar con el \textit{hardware}.

  \vspace{5mm}

  Los módulos driver tienen varios componentes diferenciados:

  \begin{enumerate}
    \item \textbf{Interfaz}: Comunica el módulo con los procesos.
    \item \textbf{Específico}: Comunica el módulo con cada uno de los componentes \textit{hardware}.
    \item \textbf{Carga}: Comunica el módulo con el sistema operativo.
    \item \textbf{Planificación de la Entrada/Salida}: Realiza los computos internos relacionados con la planificación.
    \item \textbf{Inicialización y finalización}: Encargado de controlar si el driver se encuentra inicializado o terminado.


  \end{enumerate}

  \begin{figure}[H]
    \centering
    \imgcenter[130]{Images/modulosDriver.png}
    \caption{Estructura de un Módulo Driver}
  \end{figure}

  \section{Introducción al Diseño de un Sistema de Ficheros}

  La computación y los datos están muy relacionados el uno con el otro, ya que la computación requiere de datos sobre los que trabajar, y los datos necesitan de computación para obtener conclusiones útiles.

  \vspace{2mm}

  Los datos deben estar almacenados en algun lugar dentro del ordenador. Este lugar puede ser la memoria principal o la memoria secundaria.

  \vspace{1mm}

  La \textbf{memoria principal} no guarda la información de forma persistente, tiene un poco tamaño y es muy rápida, mientras que la \textbf{memoria secundaria} si almacena los datos de forma persistente, tiene un mayor tamaño, pero es más lenta.

  \vspace{2mm}

  Hace falta un mecanismo que facilita la labor de comiunicación entre las dos memorias. Y para evitar, en la medida de lo posible, que los programadores tengan que realizar asiganciones en memoria manuales, se utiliza una abstracción intermedia, en forma de sistema de ficheros y carpetas, controlada por el kernel.

  \vspace{3mm}

  Esta abstracción ofrece una visión lógica unificada, siendo lo suficientemente simple como para que su uso sea posible y útil, pero completa, para funcionar en la gran mayoría de máquinas actuales. Todos los distintos componenetes del sistema operativo se almacenan de esta forma.

  \vspace{1mm}

  Este sistema es completamente transversal, es decir, tiene comunicación con todas las partes del sistema operativo.

  \subsubsection{Marco de Trabajo}

  Para acceder al sistema de ficheros que trabaja a nivel de bloque, es necesario usar la caché de bloques. Para ello, es necesario usar los siguientes comandos:

  \begin{itemize}
    \item \texttt{getblk}: Sirve para obtener un bloque.
    \item \texttt{brelse}: Sirve para liberar un bloque.
    \item \texttt{bwrite}: Sirve para escribir en un bloque.
    \item \texttt{bread}: Sirve para leer de un bloque
    \item \texttt{breada}: Sirve para leer de un bloque y del siguiente.
  \end{itemize}

  La caché, al recibir estas funciones, se encargará de llamar al driver manejador del dispositivo.

  \subsection{Sistema de Ficheros}

  Dentro de la memoria existen dos regiones diferentes: \textbf{Metadatos}, que permiten la locaclización de los datos de los usuarios, y los \textbf{Datos} de los usuarios.

  \vspace{2mm}

  Los metadatos tiene que estar almacenados tanto en memoria secundaria como en memoria principal.

  \vspace{3mm}

  El número de errores críticos dentro del sistema de ficheros debe ser mínimo, ya que la confianza de los usuarios en este sistema es muy grande.

  \vspace{2mm}

  Las estructuras que forman el sistema de ficeheros son:

  \begin{itemize}
    \item \textbf{Metadatos}
    \begin{itemize}
      \item \textit{Bloque de Arranque}
      \item \textit{Superbloque}
      \item \textit{Mapas de Bits}
      \item \textit{Lista de Recursos Libres}
      \item \textit{Indexación}
    \end{itemize}
    \item \textbf{Datos}
    \begin{itemize}
      \item \textit{Ficheros}
      \item \textit{Directorios}
      \item \textit{Enlaces}
    \end{itemize}
  \end{itemize}

  \subsubsection{Representación tipo Unix}

  El bloque de \textbf{i-nodos} almacena los atributos de entrada y la referenceia a los bloques de índice para cada uno de los ficheros. Actúa como índice de los ficheros.

  \vspace{2mm}

  La \textbf{asignación de recursos} almacena el mapa de bits de los bloques, e indica si están ocupados o no.

  \vspace{2mm}

  El \textbf{superbloque} almacena el número de bloques usados para los i-nodos, para asiganción de recursos, la dirección al i-nodo raíz, etc.

  \vspace{2mm}

  El \textbf{bloque de arranque} almacena el código de arranque y la tabla de particiones.

  \vspace{4mm}

  Los \textbf{ficheros} son referenciados desde los inodos. Se almacena en el i-nodo una refernecia directa al principio del fichero, y una referencia indirecta al final del mismo.

  \vspace{2mm}

  Los \textbf{directorios}  son referenciados también a través de los i-nodos, y almacenan información de los ficheros que contienen. Es tratad como un fichero especial.

  \vspace{2mm}

  Los \textbf{enlaces} se dividen en duros y blandos. Los duros son tratados como otor fichero, y tiene asigando su propio i-nodo, mientras que los blandos son tratados como accesos directos, y son accedidos desde el directorio al que pertenecen.

  \begin{figure}[H]
    \centering
    \imgcenter[160]{Images/unixFichero.png}
    \caption{Sistema de Ficheros tipo Unix}
  \end{figure}

  \subsubsection{Representación tipo FAT}

  Los bloques \textbf{FAT} almacenan la dirección a los distintos ficheros. El número que acompaña a FAT (FAT 12, FAT 16, FAT 32) indica el número de bloques de datos que almacena ($2^{12}$ bloques, $2^{16}$ bloques, $2^{32}$ bloques). Además, este bloque FAT se encuntra duplicado, como medio de recuperación de datos perdidos.

  \begin{figure}[H]
    \centering
    \imgcenter[145]{Images/fatFichero.png}
    \caption{Sistema de Ficheros tipo FAT}
  \end{figure}

  \vspace{5mm}

  En un mundo ideal, todos los metadatos se almacenarían en memoria, pero dado que esta memoria es limitada, tan solo se guarda la información estríctamente necesaria del superbloque , procesos e i-nodos de la partición en uso.

  \section{Sistema de Memoria}

  \subsection{Introducción al Sistema de Memoria}

  Un programa es una secuencia de instrucciones escritas para realiar una tarea específica en una computadora \cite{program}. Un proceso es un programa en ejecución, y su imágen en memoria es el espacio de memoria que ocupa ese proceso.

  \vspace{3mm}

  Los \textbf{Sistemas Monoprogramados} son aquellos que solo permiten la ejecución de un solo proceso simultaneamente. La memoria es compartida entre el sistema operativo y el proceso.

  \vspace{1mm}

  Los \textbf{Sistemas Multiprogramados} son aquellos que permiten la ejecución de varios procesos al mismo tiempo, gestionados por el sistema operativo. De esta forma se mejora la ocupación de la CPU.

  \vspace{5mm}

  Una \textbf{región de memoria} es una zona contigua de la imagen de un proceso, que poseen las mismas características o propiedades. Estas propiedades pueden ser:

  \begin{itemize}
    \item \textbf{Permisos}: Que pueden ser de lectura, escritura, ejecución o cualquier combinación de los anteriores.
    \item \textbf{Compartición entre hilos}: Que puede ser privada o compartida.
    \item \textbf{Tamaño}: Que puede ser fijo o variable.
    \item \textbf{Valor inicial}: Que puede ser con o sin soporte.
    \item \textbf{Creación}: Que puede ser estática o dinámica.
    \item \textbf{Sentido de Crecimiento}: Que puede ser ascendente o descendente.
  \end{itemize}

  Los procesos están formados por varias regiones.

  \vspace{3mm}

  Regiones principales:

  \begin{itemize}
    \item \textbf{Código}: Es donde se almacena el código fijo del proceso. Se encuentra en la parte inferior de la imagen.
    \item \textbf{Datos}: Es el sitio en memoria donde se almacenan las variables globales. Está dividido en dos subsecciones: región para variables con valor inicial, y región para variables sin valor inicial. Se encuentra a continuación del código.
    \item \textbf{Pila}: Es el lugar donde se almacenan las variables locales. Se encuentra en la parte superior de la imagen. Es de tamaño variable.
    \item \textbf{Región de \textit{Heap}}: Actua de soporte para la memoria dinámica. Crece de forma ascendente.
    \item \textbf{Ficheros proyectados}: Región específica para los ficheros usados en el proceso. La región del proceso está asociada a un fichero. Se direcciona a memoria para poder acceder a la información necesaria.
    \item \textbf{Bibliotecas dinámicas}: Región que almacena las bibliotecas con código y datos.
    \item \textbf{Memoria compartida}: Región que almacena la información común de varios procesos.
  \end{itemize}

  \begin{figure}[H]
    \imgcenter[50]{Images/mapaMemoria.png}
    \caption{Mapa de Memoria de un Proceso}
  \end{figure}

  \vspace{3mm}

  El soporte para memoria principal del sistema operativo permite usar más memoria de la posible en el disco. Puede hacerse por medio de \textbf{paginación}, \textbf{segmentación} o \textbf{segmentación paginada}.

  \begin{itemize}
    \item \textbf{Paginación}: Dividir la dirección virtual en páginas, para trabajar a nivel de página en lugar de byte. Se divide la memoria en bloques de tamaño fijo, y se enlaza la mmoria virtual y la memoria física.
    \item \textbf{Segmentación}: Dividir la memoria en secciones de tamaño variable denominados segmentos, en lugar de tamaño fijo. Se utiliza una tabla de segmentos para la correspondencia entre la memoria física y la memoria virtual.
    \item \textbf{Segmentación paginada}: Utiliza segmentos divididos en páginas. La tabla de segmentos lleva a una tabal de paginación, y después accede a memoria principal o a disco según corresponda. Dado que estas tablas son muy grandes, se utilizan tabalas multinivel.
  \end{itemize}


  \subsection{Gestión de Memoria}

  La gestión de memoria es el ámbito encargado de gestionar la memoria entre los distintos procesos y el sistema operativo.

  \begin{figure}[H]
    \imgcenter[130]{Images/gestionMemoria.png}
    \caption{Esquema de la Arquitectura Moderna de Gestión de Memoria}
  \end{figure}

  Objetivos principales de la memoria:

  \begin{enumerate}
    \item Localizar las referncias a memoria, traduciendolas como direcciones físicas.

    Esto es necesario porque así se evita que el programador tenga que conocer dónde se va a colocar el programa dentro de la memoria al ejecutar.
    \item Proteger los espacios de memoria, para evitar accesos a información de otros procesos sin los permisos necesarios.

    Para conseguir esto, las posiciones de memoria deben ser comprobadas en tiempo de ejecución, y tienen que comprobarse por \textit{hardware}.
    \item Compartir los espacios de memoria comunes entre distintos procesos.

    Esta función debe ser tanto solicitada como aceptada explícitamente, para evitar accesos a la información de los procesos de forma indeseada.
    \item Realizar la organización lógica de los programas, dividiendolos en módulos independientes.

    Esto significa gestionar correctamente cada una de las regiones de un proceso, ya que todos los procesos no tienen las mismas regiones,
    \item Realizar la organización física de la memoria, organizándola de forma óptima para alojar los diferentes programas y módulos.

    Permite ejecutar procesos que requieren más memoria de la que hay  disponible en un momento concreto, y evita la pérdida de memoria por fragmenteación del disco.
  \end{enumerate}

  La memoria a la que tiene acceso cada proceso consiste en un espacio de direcciones plano y lineal. Además, el espacio del \textit{kernel} es compartido por todo el resto de procesos.



  \section{Aspectos avanzados}

  \subsection{Seguridad en sistemas operativos}

  Los requisitos de seguridad de un sistema operativo utilizan los conceptos y bases de la \textbf{Teoría de la Comunciación}, y sigue un proceso similar al mostrado en el siguiente esquema:

  \begin{figure}[H]
    \imgcenter[130]{Images/comunicacion.png}
    \caption{Esquema de Comunicación Básico}
  \end{figure}

  Los requisitos de seguridad de un sistema operativo son:

  \begin{itemize}
    \item \textbf{Confidencialidad}

    Consiste en restringir el acceso a usuarios no autorizados a la información del sistema informático. Para ello, es necesario que el sistema sea capaz de autorizar o autentificar a los usuarios a través de su identidad.

    \item \textbf{Integridad}

    Consiste en evitar que usuarios no autorizados puedan miodificar cualquier elemento del sistema informático.

    \item \textbf{Disponibilidad}

    Consiste en habilitar los elementos del sistema informático a los usuarios habilitados.

  \end{itemize}

  Existen dos formas de aplicar la seguridad informática: \textbf{Seguidad Física}, que utiliza medios físicos para aplicar la seguridad (Cerrojos, puertas...) y \textbf{Seguridad Lógica}, que utiliza mecanismos lógicos, como las contraseñas o las claves.

  \vspace{3mm}

  Las amenzas a la seguridad que sufren los sistemas operativos se pueden categorizar en 4 tipos:

  \begin{itemize}
    \item \textbf{Interrupción}:

    Consiste en atacar la disponibilidad del sistema operativo, eliminando cualquier elemento que forma parte del proceso de comunicación.

    \item \textbf{Intercepción}:

    Consiste en el acceso de un usuario no autorizado a un elemento del sistema operativo. Es un ataque que afecta la confidencialidad.

    \item \textbf{Modificación}:

    Es un atque que afecta a la integridad, y consiste en que un usuario no autorizado accede y modifica un elemento del sistema.

    \item \textbf{Invención}:

    También es un ataque que vulnera la integridad, y consiste en insertar archivos nuevos al sistema sin tener autorización.

  \end{itemize}

  A la hora de diseñar el sistema de seguridad de un sistema operativo es necesario tener en cuenta los principios de seguridad:

  \begin{enumerate}
    \item \textbf{El principio de necesidad de saber}

    Es aquel que dice que solo debe mostrarse información a aquel que la solicita, y en el grado que la solicita, y de su autorización.

    \item \textbf{El principio de diseño intrínseco de la seguridad}

    Debe ser algo básico de todos los sistemas tener algun método de protección.

    \item \textbf{El principio del mínimo privilegio}

    Cada elemento del sistema debe tener el menor privilegio posible que le permita realizar sus tareas correctamente.

    \item \textbf{El principio del ahorro de mecanismos}

    Los sistemas usados para facilitar la seguridad deben ser tan pequeños y simples como sea posible.

    \item \textbf{El principio de aceptación}

    Los sistemas de seguridad deben evitar entrometerse en la realización de las tareas del sistema informático siempre que sea posible.

    \item \textbf{El principio de mediación total}

    El acceso al control de los sistemas de seguridad debe hacerse con la información de control necesaria.

    \item \textbf{El principio de diseño abierto}

    La seguridad de un dispositivo no debe depende de cuanto de secreto es un algoritmo, si no de su funcionamiento correcto.

  \end{enumerate}

  \subsection{Tolerancia a fallos en sistemas operativos}

  \vspace{3mm}

  La tolerancia a fallos es la propiedad que le permite a un sistema seguir funcionando correctamente en caso de fallo de uno o varios de sus componentes. Un diseño tolerante a fallos es un sistema que está capacitado para continuar su funcionamiento cuando algún componente del sistema falla\cite{tolerancia}.

  \vspace{6mm}

  El objetivo no es construir un sistema perfecto que no cometa fallos, ya que esto es algo imposible, si no un sistema que pueda seguir funcionando correctamente cuando se encuentra con un fallo. Estos sistemas suelen estar diseñados para tener una vida útil larga, que son difíciles de mantener, que tienen una disponibilidad añta, e implementan aplicaciones críticas.

  \begin{figure}[H]
    \imgcenter[150]{Images/fallos.png}
    \caption{Esquema de la Progresión de los Errores}
  \end{figure}

  \subsection{Sistemas distribuidos}

  Un sistema distribuido es un conjunto de ordenadores que trabajan juntos de forma coordinada, a través del intercambio de mensajes, para conseguir un objetivo. En dicho sistema, el estado y los programas se guardan en múltiples ordenadores. A pesar de que los procesos que tienen lugar están separados entre los diferentes participantes, para el usuario parece que está trabajando con un único ordenador\cite{distr}.

  \vspace{5mm}

  \begin{figure}[H]
    \imgcenter[120]{Images/distr.jpg}
    \caption{Esquema de un Sistema Distribuido\cite{distr2}}
  \end{figure}

  Las principales ventajas y desventajas de los sistemas distribuidos son:

  \begin{center}
    \begin{tabular}{ p{0.5\textwidth} || p{0.5\textwidth} }
      \textbf{Ventajas} & \textbf{Desventajas} \\
      \hline
      \hline
      Se comparten los recursos de \textit{hardware}, \textit{software} y de datos & Tiene una complejidad muy alta\\
      &  \\
      La escalabilidad se hace añadiendo nuevo \textit{hardware} & Depende en gran manera de la interconexión\\
      &  \\
      Tiene un rendimiento muy alto gracias al gran número de procesadores & Posee un menor grado de seguridad \\
      &  \\
      Tolerancia a errores, gracias al gran número de procesadores e información replicada & El \textit{software} del sistema operativo es más complejo\\
      &  \\
      Relación muy buena entre rendimiento y coste & Necesiadad de repartir la carga de trabajo eficientemente\\
      &  \\
    \end{tabular}
  \end{center}

  \subsection{Sistemas de tiempo real}

  Un sistema operativo de tiempo real es aquel que ha sido desarrollado para aplicaciones de tiempo real. Como tal, se le exige corrección en sus respuestas bajo ciertas restricciones de tiempo. Si no las respeta, se dirá que el sistema ha fallado. Para garantizar el comportamiento correcto en el tiempo requerido se necesita que el sistema sea predecible\cite{real}.

  \vspace{2mm}

  El procesamiento a tiempo real es aquel en el que la corrección y exactitud del sistema se mide en función del resultado obtenido y el instante en el que el resultado se produce. PAra ello, necesita que los procesos se ejeuten a tiempo real, y tienen que reaccionar a sucesos externos.

  \vspace{3mm}

  Clasificación de los sistemas operativos de tiempo real:

  \begin{itemize}
    \item \textbf{\textit{Hard-real time}}

    El periodo de tiempo es muy importante y tiene que cumplirse estrictamente. Las tareas suelen ser críticas, y durante periodods de tiempo muy pequeños.

    \item \textbf{\textit{Soft-real time}}

    El periodo de tiempo es importante pero no estricto. Suelen ser tareas no críticas, durante un tiempo más largo.

    \item \textbf{\textit{Firm-real time}}

    El periodo de tiempo es muy importante, y una tarea fuera de plazo es inutil, pero no poduce errores.

  \end{itemize}

  Requisitos de los sistemas operativos de tiempo real:

  \begin{enumerate}
    \item \textbf{Determinismo}

    Los sistemas deterministas son aquellos que realizan sus operaciones siempre de la misma forma, ocupando el mismo tiempo. Es decir, no se ven involucrados factores aleatorios.

    \item \textbf{Sensibilidad}

    Hace referencia a el tiempo que tarda el sistema en dar servico a una interrupción, una vez ha sido reconocida.

    \item \textbf{Control del usuario}

    Esta característica es mayor en los sietemas operativos de tiempo real que en los sistemas operativos convencionales. En los de tiempo real, es necesario permitir a los usuarios decidir la prioridad de las tareas.

    \item \textbf{Fiabilidad}

    Es extremadamente necesaria, dado que responde a los suscesos que recibe al momento.

    \item \textbf{Tolerancia a fallos}

    Al igual que la fiabilidad, es extremadamente necesaria, y por el mismo motivo.
  \end{enumerate}






  \newpage

  \begin{thebibliography}{9}
    \bibitem{imagenSO}
    Sistema operativo. En Wikipedia. Recuperado el 16 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Sistema_operativo}

    \bibitem{hipervisor}
    Hipervisor. En Wikipedia. Recuperado el 16 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Hipervisor}

    \bibitem{msdos}
    tutorialspoint, Operating System Structure. Kristi Castro. Recuperado el 16 de mayo de 2020, de \url{https://www.tutorialspoint.com/Operating-System-Structure}

    \bibitem{proceso}
    Proceso (informática). En Wikipedia. Recuperado el 23 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Proceso_(inform%C3%A1tica)}

    \bibitem{periferico}
    Periférico (informática). En Wikipedia. Recuperado el 24 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Perif%C3%A9rico_(inform%C3%A1tica)}

    \bibitem{E/S}
    Arquitectura del sistema de E/S. Lección 3c procesos, periféricos, drivers y servicios ampliados. Grupo ARCOS, Departamento de Informática, Universidad Carlos III de Madrid. Diapositiva 22. Recuperado el 27 de mayo de 2020, de \url{https://aulaglobal.uc3m.es/pluginfile.php/3449191/mod_resource/content/18/dso-clases-3c-ppdsa_drv_sa-v5e.pdf} (Puede que no sea visisble a no miembros de la Universidad Carlos III de Madrid)

    \bibitem{program}
    Programa informático. En Wikipedia. Recuperado el 30 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Programa_inform%C3%A1tico}

    \bibitem{tolerancia}
    Diseño de tolerancia a fallos. En Wikipedia. Recuperado el 31 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Dise%C3%B1o_de_tolerancia_a_fallos}

    \bibitem{distr}
    Medium, ¿Qué es un sistema distribuido?. Adrian Rodriguez. Recuperado el 31 de mayo de 2020, de \url{https://medium.com/@adr.rod87/qu%C3%A9-es-un-sistema-distribuido-442870a40bc4}

    \bibitem{distr2}
    ScienceDirect, Distributed Computing. Dinkar Sitaram, Geetha Manjunath. Recuperado el 31 de mayo de 2020, de \url{https://www.sciencedirect.com/topics/computer-science/distributed-computing}

    \bibitem{real}
    Sistema operativo de tiempo real. En Wikipedia. Recuperado el 31 de mayo de 2020, de \url{https://es.wikipedia.org/wiki/Sistema_operativo_de_tiempo_real}



  \end{thebibliography}





\end{document}
